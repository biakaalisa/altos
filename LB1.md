# 1. Подготовка среды Установить на виртуальной машине Debian 11/12 (VMware\VirtualBox\HyperV\WSL). Убедиться, что система обновлена (команда apt-get update && apt-get upgrade – обязательно понимать разницу команд).
![image](https://github.com/user-attachments/assets/f13ed0a6-b49a-4cc2-b4b6-d310b0ddee55)
apt-get update – обновляет о доступных пакетах. Проверяет репозитории на наличие новых версий, но не устанавливает их.

apt-get upgrade - устанавливает обновления для уже установленных пакетов.

apt install – для установки новых пакетов

apt – пакетный менеджер для управления пакетами

пакеты — это архивы, содержащие программное обеспечение, библиотеки, конфигурационные файлы и метаданные, необходимые для установки и управления программами в системе. Пакеты упрощают установку, обновление и удаление программ, а также управление зависимостями между ними.


1.	http://security.debian.org/debian-security bookworm-security InRelease:
  Это репозиторий безопасности для Debian. Он содержит обновления, связанные с безопасностью, для вашей версии Debian (в данном случае — bookworm). InRelease — это файл, содержащий информацию о пакетах в репозитории, включая их подписи для проверки подлинности.

2.	http://deb.debian.org/debian bookworm InRelease:
  Это основной репозиторий Debian для версии bookworm. Он содержит большинство пакетов, включая основные программы и библиотеки. InRelease — аналогично, файл с информацией о пакетах.

3.	http://deb.debian.org/debian bookworm-updates InRelease:
  Это репозиторий обновлений для версии bookworm. Он содержит обновления пакетов, которые не связаны с безопасностью, но важны для стабильности и функциональности системы. InRelease — файл с информацией о пакетах.
![image](https://github.com/user-attachments/assets/77f466a1-8561-400a-aea5-075456cbf02e)


# 2. Установка PostgreSQL С помощью пакетного менеджера apt установить PostgreSQL (последнюю доступную версию из репозиториев). Привести команды установки и их объяснение.

![image](https://github.com/user-attachments/assets/1379022a-5cec-406b-96e1-ed64880672a6)
![image](https://github.com/user-attachments/assets/67452356-206b-458f-a0da-8f57b43567fe)
Для установки PostgreSQL использовали команду

      sudo apt install postgresql

sudo: Выполнение команд, требующих прав root
   
apt: Пакетный менеджер для управления пакетами


Отличие sudo от su:

  +	sudo выполняет одну команду с правами root, а su переключает пользователя на root (или другого пользователя) до тех пор, пока вы не выйдете из сессии.

  +	sudo требует пароль текущего пользователя, а su — пароль целевого пользователя (обычно root).
  ![image](https://github.com/user-attachments/assets/c8e66491-6dde-4e0b-b461-64b99bdbd25d)
После установки при помощи sudo systemctl status postgresql проверили статус postgres, точно ли он установился и правильно ли он работает.
# 3. Создание служебной учётной записи. Проверить, что при установке создана учётная запись postgres. Объяснить её назначение и права в системе.

![image](https://github.com/user-attachments/assets/0ecfaf49-cdf1-4cd7-aa9b-49b28b887aba)
      
Командой sudo -i -u postgres переключились на пользователя postgres

         sudo -i -u postgres
         
1.	sudo:
   
  +	Это команда, которая позволяет выполнять другие команды с привилегиями суперпользователя (root) или другого пользователя. В данном случае она используется для переключения на пользователя postgres.

2.	-i:
   
  +	Этот флаг указывает sudo запустить интерактивную оболочку (login shell). Это означает, что будет загружена среда пользователя, включая его переменные окружения, профили и настройки оболочки.
  
  +	По сути, это аналогично входу в систему как пользователь postgres.

3.	-u postgres:
   
  +	Этот флаг указывает sudo переключиться на пользователя postgres. Вместо выполнения команды от имени root, команда будет выполнена от имени указанного пользователя.
  После того, как зашли postgres-пользователем запустили терминал PostgreSQL командой
  
        psql
      
Назначение пользователя postgres:

  + Пользователь postgres создаётся автоматически при установке PostgreSQL. Он является владельцем всех файлов, связанных с PostgreSQL.
    
  + Пользователь postgres используется для запуска и остановки сервера PostgreSQL.
    
  + Все процессы PostgreSQL (например, postmaster) запускаются от имени этого пользователя.
    
  + Пользователь postgres имеет полный доступ ко всем базам данных, таблицам и другим объектам в PostgreSQL.
    
  + Он может создавать, изменять и удалять базы данных, пользователей и роли.



Права пользователя postgres:

  + Пользователь postgres является владельцем каталога данных PostgreSQL (например, /var/lib/postgresql).
    
  + Он имеет права на чтение, запись и выполнение в этом каталоге и его подкаталогах.
    
  + Внутри PostgreSQL пользователь postgres имеет роль суперпользователя (superuser).
    
  + Пользователь postgres обычно не имеет прав суперпользователя (root) в системе. Это сделано для безопасности. Однако он может выполнять команды, связанные с управлением PostgreSQL, такие как запуск и остановка сервера.

# 4.	Первичная настройка конфигурационных файлов Найти и изучить основные файлы конфигурации PostgreSQL (например, postgresql.conf, pg_hba.conf). Внести изменения (например, задать порт, при необходимости изменить метод аутентификации) и перезапустить сервис PostgreSQL.
![image](https://github.com/user-attachments/assets/b8d06a45-ee81-4a88-8f26-1162ea97c950)

Файл postgresql.conf в самом начале. Будем менять строку listen_adress, отвечающую за настройку сетевых интерфейсов (именно в ней прописаны адреса, с которых доступно подключение к postgresql). По умолчанию у данного параметра стоит значение localhost, что значит, что подключение доступно только в Debian. Для того, чтобы в дальнейшем иметь возможность подключения и в window на нашем устройстве, заменим значение этого параметра на *,  тем самым давая возможность подключения со всех адресов.
![image](https://github.com/user-attachments/assets/74aab156-91c0-4b59-a44e-5d48baa35d3a)
  Командой sudo nano /etc/postgresql/15/main/postgresql.conf заходим в файл и редактируем строку, описанную выше. 
  
        sudo nano /etc/postgresql/15/main/postgresql.conf
        
Сохраняем изменения и перезапускаем нас сервер при помощи 

      sudo systemctl restart postgresql

![image](https://github.com/user-attachments/assets/0e91f39e-981f-41e2-8eb7-7d9e32c99b85)

# 5. Управление сервисом Использовать инструменты управления сервисами Debian (systemd) — проверить статус сервиса PostgreSQL, включить автозапуск.
![image](https://github.com/user-attachments/assets/37027ee2-b11a-4f81-a132-16cb3e4b7fc5)

Для включения автозапуска использовали команду sudo systemctl enable postgresql (enable - подкоманда systemctl, которая включает автозапуск сервиса при загрузке системы)

      sudo systemctl enable postgresql

# 6. Создание тестовой базы данных Создать отдельного пользователя (логин задать в формате ФИО, например, alpopov) в PostgreSQL, новую базу данных (нейминг аналогичен dbalpopov), задать ему пароль. Использовать psql, чтобы проверить доступ      
![image](https://github.com/user-attachments/assets/bd0bd9f2-e98c-4953-b68e-a9086eb72d6b)
![image](https://github.com/user-attachments/assets/a7a82a90-acde-430e-8859-9fe06887cb98)
![image](https://github.com/user-attachments/assets/403264c5-49fb-4016-b431-71fbd16c96b3)

Для создания нового пользователя использовали PSQL-запись:

      CREATE USER <userName> WITH PASSWORD ‘<userPassword>’;

После этого для нового пользователя создали базу данных, так же используя PSQL-запись:

      CREATE DATABASE <dbName> OWNER <userName>;

Для того, чтобы проверить, точно ли все создалось как надо использовали команды:
+	\du -  возвращает список пользователей (ролей) в PostgreSQL, а также их атрибуты и привилегии.
+	\l - возвращает список баз данных на сервере PostgreSQL.

При входе в psql от лица нового пользователя была проблема в том, postgres ругался на проверку подлинности нового пользователя, связано это было с тем, что в файле pg_hba.conf была строка:

                    local 	all		all		peer,
                                   
В которой значение peer говорит о том, что postgresql разрешает подключение только тем пользователям, что есть в системе Linux. Чтобы это исправить и сделать возможным вход по паролю пользователя заменили peer на md5

                    local 	all		all		md5
                                   
после этого любой пользователь postgresql может войти использую свой пароль, который мы ранее использовали для создания.
![image](https://github.com/user-attachments/assets/0c07f2e1-529d-4da7-b890-cd794b556846)
Далее, для подключения к базе от лица нового пользователя прописали:

      psql -U <userName> -d <dbName> -W

И для окончательной проверки того, что зашли мы не от лица postgres вызвала командой 

      SELECT current_user;  
      
имя пользователя текущей сессии.
![image](https://github.com/user-attachments/assets/32476b87-1f0d-4baf-95c8-874e985c4c68)

Однако, когда мы пошли делать следующие задания столкнулись с проблемой, что теперь перед запуском psql требуется пароль postgres-пользователя, который мы не задавали и который пустым не являлся. Далее в лабораторной работе мы его поменяем, но пока, чтобы обойти эту проблему в pg_hba.conf вернули строку

                    local 	all		all		peer

 # 7.	Знакомство со схемами. Объяснить, что такое схема в PostgreSQL, в чём разница между базой данных и схемой. По умолчанию существует схема public. Создайте ещё одну схему, например, test_schema. Настройте у пользователя, созданного выше, права на использование этой схемы (команда GRANT). Продемонстрируйте, как работать с разными схемами (смена search_path или обращение к объектам через test_schema.table_name).

База данных — это основное хранилище, в котором могут находиться схемы. В ней хранятся:
+	Схемы (как папки для структурирования данных).
+	Пользователи и их права доступа.
+	Журналы транзакций.
+	Настройки базы данных.

Схема — это область внутри базы данных, в которой хранятся объекты, в том числе и таблицы, в которых храниться информация
![image](https://github.com/user-attachments/assets/408adc4e-37cc-48d9-bf6c-cd3e86c2ed2c)
Для создания новой схемы используется команда 

      CREATE SCHEMA <schemaName>;

Для предоставления прав на использование объектов схемы:

      GRANT USAGE ON SCHEMA <schemaName> TO <userName>;

Для предоставления прав на создание объектов в схеме пользователем используется:
  
      GRANT CREATE ON SCHEMA <schemaName> TO <userName>;

![image](https://github.com/user-attachments/assets/3b2e55de-f7e0-4734-9b54-8d3fe636cb18)

Для проверки вызвали /dn+, который возвращает список схем и их описание. В нем же видим, что пользователь asstarikova  в схеме test_schema может: 
+	U — USAGE (право на использование объекта, например, схемы или последовательности).
+	C — CREATE (право на создание объектов в схеме).
  
        /dn+

![image](https://github.com/user-attachments/assets/1e73e2fb-e0e3-42da-bcfd-96b5f032ecad)

      SET search_path TO <schemaName>;

позволяет указать, в каких схемах PostgreSQL будет искать объекты, если схема не указана явно. 
search_path — это список схем, которые PostgreSQL проверяет при поиске объектов. По умолчанию search_path включает схему public, а также схему, соответствующую имени текущего пользователя. Если объект не указан с явным именем схемы (например, schema_name.table_name), PostgreSQL ищет его в схемах, перечисленных в search_path, в порядке их указания.

# 8. Использование утилиты psql для базовых операций. В схеме public создать тестовую таблицу, внести несколько записей, выполнить основные SQL-запросы (SELECT, INSERT, UPDATE, DELETE). В схеме из 7 задания test_schema создать другую таблицу и внести несколько записей. Покажите, как к ней обращаться. Использовать скрипт, который демонстрирует создание таблицы с привязкой к конкретной схеме.
![image](https://github.com/user-attachments/assets/4da785bd-9319-448b-845a-187f924fcce7)
![image](https://github.com/user-attachments/assets/8789578a-9c08-42e1-95bc-37dd94b4ad62)
Для создания таблицы использовали метод 

      CREATE_TABLE <tableName> (<tableColumns with types>);

Где вместо tableColumns with types указывает названия столбцов и тип данных, который будет в них использоваться.
![image](https://github.com/user-attachments/assets/17855572-c620-4d40-819f-6acb6a1e5a7b)

Методом \d \<schema.table> получили все поля с типами данных, которые они ожидают у определенной таблицы.

      \d <schema.table>

Для заполнения таблицы данными использовали

      INSERT INTO <schema.table> (<columns>) VALUES (<data>);
      
Где \<columns> - названия столбцов, в которые будут вноситься данные, а \<data> - как раз-таки данные, которые будут записываться.

После для того, чтобы проверить, что все записалась куда надо прописали

      SELECT * FROM < schema.table >;

Где * означает, что должны быть выведены значения всех столбцов. 
Если же нам потребовалось вывести значения одного или нескольких столбцов, но не всей таблицы, то можно было бы перечислить их названия вместо *.
![image](https://github.com/user-attachments/assets/da432567-18d5-4cde-ab14-92ebbc7d708b)
В существующей таблице записи изменили значение поля name на другое, используя:

      UPDATE <schema.table> SET <columnName> WHERE <condition>;

Где schema.table – название таблицы, данные в которой мы будем редактировать, 
columnName – название столбца, в котором мы будем менять значения, condition – условие, по которому мы находим нужную строку, в которой будут происходить изменения

Добавили новую запись уже известным методом INSERT INTO и после этого удалили ее при помощи записи:

      DELETE FROM < schema.table > WHERE <condition>

Где schema.table – название таблицы, данные в которой мы будем редактировать, 
columnName – название столбца, в котором мы будем менять значения, condition – условие, по которому мы находим нужную строку, в которой будут происходить изменения
![image](https://github.com/user-attachments/assets/3ff3ae00-7b43-4b5a-9c8d-b7220911c0ea)
![image](https://github.com/user-attachments/assets/27471231-49a2-4730-93e6-5401a78d2776)
Создали еще одну таблицу и тоже заполнили ее данными. Вывели их значения.

# 8.	Настройка локальных и сетевых подключений Настроить доступ к базе данных по локальной сети (например, разрешить подключаться к PostgreSQL с другого хоста). Объяснить параметры listen_addresses и формат строки в pg_hba.conf. Произвести подключение через pgadmin или dbeaver с локальной машины.
![image](https://github.com/user-attachments/assets/b8a095b9-24b8-4e9c-9f41-f8f724c1e0d3)
В начале лабораторной работы меняли файл конфигурации postgresql.conf, чтобы разрешить PostgreSQL слушать соединения с других хостов.	В нем нашли параметр listen_addresses, который указывает, на каких IP-адресах PostgreSQL будет слушать соединения. И изменили его значение на:

      listen_addresses = '*'
      
Это позволит PostgreSQL слушать на всех доступных IP-адресах. 
Для редактирования файлов использовали  
![image](https://github.com/user-attachments/assets/4d99ef57-9200-4630-85c3-893fed76bb10)
![image](https://github.com/user-attachments/assets/a409e70e-eb45-46f6-8fa8-57f34657d224)
Далее - настроили файл доступа pg_hba.conf, чтобы разрешить подключения с других хостов.
+	host — указывает, что подключение происходит через TCP/IP.
+	all — означает, что разрешены подключения ко всем базам данных.
+	all — разрешение для всех пользователей.
+	192.168.1.0/24 — это диапазон IP-адресов сети, которому разрешено подключаться. Мы будем использовать 0.0.0.0/0, которые позволяет подключаться к серверу со всех адресов.
+	md5 — метод аутентификации, который требует использования пароля, зашифрованного методом MD5.
  
        host    all             all             0.0.0.0/0               md5

После того, как сделали возможным подключение к нашему postgres-серверу, командой ip a узнали адрес нашего сервера, по которому будем подключаться в pgAdmin
![image](https://github.com/user-attachments/assets/1d9912f8-0db3-47c9-9a34-456f3f4a939c)
![image](https://github.com/user-attachments/assets/4e137dc0-0427-4b56-9f82-57bf241c2ffe)
В настройках виртуальной машины сменили настройку параметра Attached to: на Bridged Adapter. Это нужно для того, чтобы виртуальная машина была доступна из внешней сети. По факту в этом режиме виртуальная машина становится полноценным участником сети, получает IP-адрес из той же сети, что и хост, и может взаимодействовать с другими устройствами в сети.
![image](https://github.com/user-attachments/assets/d5bee937-b0ce-4d74-a530-134d52e5189c)
В pgAdmin создали новый сервер и перешли по вкладке Register -> Server. В Connection заполняем поля:
 + Host nаme/address – адрес виртуальной машины, который мы получили методом ip a на Debian
 + Port – 5432 – значение по умолчанию, которое используется на postgres-серверах
 + Username – имя пользователя, от которого мы будет подключаться к бд
 + Password – пароль пользователя, который мы указали  ранее писали, что postgres – пользователь, который создается автоматически и пароль от которого мы не знаем. Методом ALTER USER <userName> WITH PASSWORD '\<newPassword>';  мы изменили пароль пользователя, на известный нам)

          ALTER USER \<userName> WITH PASSWORD '<newPassword>';
      
![image](https://github.com/user-attachments/assets/8bb9e347-311b-41ec-87c1-29ee48f3fe69)
После всех этих действий мы имеем доступ к нашему серверу на Debian с windows.

# 9.	Журналирование (logging). Изменить настройки журналирования в postgresql.conf, перезапустить сервис и проверить, как новые логи записываются. Найти логи в Debian и вывести примеры строк лога.

Для того, чтобы настроить журналирование изменили очень много строк в файле  postgresql.conf.
Основные параметры логирования

      logging_collector = on
      
Включает сборщик логов PostgreSQL. Если этот параметр выключен (off), логи могут записываться в syslog или journald (в зависимости от системы), но не в отдельный файл. 

Нужно чтобы PostgreSQL записывал логи в файлы, а не только в системный журнал.
________________________________________

      log_directory = 'log'

Определяет каталог, куда PostgreSQL будет сохранять файлы логов.
По умолчанию log, но можно изменить, например:
________________________________________
      
      log_filename = 'postgresql.log'
      
Определяет имя файла лога. 
________________________________________
      
      log_statement = 'all'
      
Определяет, какие SQL-запросы логировать. Возможные значения:

+	none — не записывать SQL-запросы.
+	ddl — записывать только изменения структуры БД (CREATE, ALTER, DROP).
+	mod — записывать изменения данных (INSERT, UPDATE, DELETE, TRUNCATE).
+	all — записывать все запросы.
________________________________________
     
      log_min_messages = info
      
Определяет минимальный уровень сообщений, которые будут записываться в лог. Возможные значения:

+	debug5, debug4, debug3, debug2, debug1 — детальное отладочное логирование.
+	info — информационные сообщения.
+	notice — важные, но не критические уведомления.
+	warning — предупреждения.
+	error — ошибки, но сервер продолжает работать.
+	fatal — критические ошибки, приводящие к завершению соединения.
+	panic — серверная ошибка, требующая перезапуска.
________________________________________

      log_min_error_statement = error

Определяет минимальный уровень ошибок, при котором в лог будет записываться сам SQL-запрос, вызвавший ошибку. Нужно чтобы видеть не только ошибки, но и какие запросы их вызвали.

Пример вывода в логе, если log_min_error_statement = error:

2025-03-19 12:35:25 UTC [12349] ERROR:  relation "customers" does not exist

2025-03-19 12:35:25 UTC [12349] STATEMENT:  SELECT * FROM customers;

Здесь видно, что ошибка relation "customers" does not exist была вызвана запросом SELECT * FROM customers;.
________________________________________
      
      log_connections = on
      
Логирует все новые подключения к базе данных. Позволяет отслеживать, кто и когда подключался.
________________________________________
      
      log_disconnections = on
      
Логирует отключения пользователей от базы данных. Позволяет видеть, как долго длилась сессия.

Пример вывода в логе:

2025-03-19 12:42:10 UTC [12350] LOG:  disconnection: session time: 0:02:09 user=postgres database=mydb host=192.168.1.100 port=54321

Здесь видно, что пользователь postgres работал в базе mydb 2 минуты 9 секунд.
# 10.	Назначение ролей и прав Создать роль с ограниченными привилегиями и протестировать, какие операции она может выполнять (роль назвать limited_user). Продемонстрировать, как в PostgreSQL наследуются права между ролями. Объяснить выдачу прав через GRANT.
![image](https://github.com/user-attachments/assets/fc061549-c0d0-4aa2-b348-5ad1fee6ccb8)
Для создания роли, точнее – пользователя использовали 

      CREATE ROLE <roleName> WITH LOGIN PASSWORD <rolePassword>;

Для создания просто роли, не пользователя необходимо прописать

      CREATE ROLE <roleName>;

Отличие пользователя от роли заключается в том, что пользователь может входить в базу, иметь пароль, так же пользователь не может использоваться как группа. Роль же может объединять пользователей и давать им какие-то определенное привилегии.
![image](https://github.com/user-attachments/assets/1419d87e-4c09-4cc6-b620-ccf2ab6a1aeb)
Для того, чтобы добавить прав роли/пользователю использовали:

      GRANT <rights> ON <tableName> TO <role>;

Где rights – одно или несколько из значений:
+	SELECT — право на чтение данных (выполнение запросов SELECT).
+	INSERT — право на вставку новых строк (выполнение запросов INSERT).
+	UPDATE — право на обновление существующих строк (выполнение запросов UPDATE).
+	DELETE — право на удаление строк (выполнение запросов DELETE).
+	TRUNCATE — право на очистку таблицы (выполнение команды TRUNCATE).
+	REFERENCES — право на создание внешних ключей (FOREIGN KEY), ссылающихся на эту таблицу.
+	ALL PRIVILEGES — все доступные права на таблицу.
![image](https://github.com/user-attachments/assets/1dc6007c-ef37-47c9-8a08-c90d097ddc76)
Данным запросом мы можем просмотреть, какими именно привилегиями обладает роль limited_user, а именно - может просматривать данные в таблице test схемы public.
![image](https://github.com/user-attachments/assets/e8b0309d-1b00-4db2-b3c8-540fc3dbbdd6)
Так роль, которую мы создали ранее имеет доступ только с просмотром данных внутри бд. При попытке изменения и удаления возникает ошибка о том, что у нас нет доступа к таблице.
![image](https://github.com/user-attachments/assets/60ac83ab-c790-402a-bb44-7b7c6cb0cc44)
Тут же мы создали роль limited, которая унаследовала все права роли limited_user так же при помощи метода GRANT:

        GRANT <role with rights> TO <role without rights>;

Где \<role with rights> - роль, которая передает свои права и делает своим членом роль \<role without rights>.
